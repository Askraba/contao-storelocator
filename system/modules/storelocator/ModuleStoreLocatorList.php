<?php if (!defined('TL_ROOT')) die('You can not access this file directly!');/** * Contao Open Source CMS * Copyright (C) 2005-2012 Leo Feyer * * Formerly known as TYPOlight Open Source CMS. * * This program is free software: you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation, either * version 3 of the License, or (at your option) any later version. *  * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU * Lesser General Public License for more details. *  * You should have received a copy of the GNU Lesser General Public * License along with this program. If not, please visit the Free * Software Foundation website at <http://www.gnu.org/licenses/>. * * PHP version 5 * @copyright  numero2 - Agentur für Internetdienstleistungen <www.numero2.de> * @author     Benny Born <benny.born@numero2.de> * @package    storelocator * @license    LGPL * @filesource */class ModuleStoreLocatorList extends Module {	/**	 * Template	 * @var string	 */	protected $strTemplate = 'mod_storelocator_list';			/**	 * Display a wildcard in the back end	 * @return string	 */	public function generate() {		if( TL_MODE == 'BE' ) {			$objTemplate = new BackendTemplate('be_wildcard');			$objTemplate->wildcard = '### STORELOCATOR LIST ###';			$objTemplate->title = $this->headline;			$objTemplate->id = $this->id;			$objTemplate->link = $this->name;			$objTemplate->href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $this->id;			return $objTemplate->parse();		}				return parent::generate();	}			/**	 * Generate module	 */	protected function compile() {		$this->Template = new FrontendTemplate($this->storelocator_list_tpl);				$sSearchVal = $this->Input->post('storelocator_search_name') ? $this->Input->post('storelocator_search_name') : NULL;		$sSearchCountry = $this->Input->post('storelocator_search_country') ? $this->Input->post('storelocator_search_country') : NULL;		// add country code for correct search results		if( !empty($sSearchCountry) ) {			$sSearchVal .= ', '.$sSearchCountry;		}				$aCategories = array();		$aCategories = deserialize($this->storelocator_list_categories);				$aEntries = array();				if( !empty($sSearchVal) ) {					// get coordinates of searched destination			$aCoordinates = array();						$sResponse = NULL;			$sResponse = file_get_contents("http://maps.google.com/maps/geo?q=".rawurlencode($sSearchVal)."&output=json&oe=utf8&sensor=false&hl=de");						if( !empty($sResponse) ) {							$aResponse = array();				$aResponse = json_decode($sResponse,1);				if( !empty($aResponse['Status']) && $aResponse['Status']['code'] == '200' ) {									$aCoordinates['latitude'] = $aResponse['Placemark'][0]['Point']['coordinates'][1];					$aCoordinates['longitude'] = $aResponse['Placemark'][0]['Point']['coordinates'][0];				}			}					if( !empty($aCoordinates) ) {				$objCategories = NULL;				$objCategories = $this->Database->execute(" SELECT * FROM tl_storelocator_stores WHERE pid IN(".implode(',',$aCategories).") ORDER BY city DESC ");								while( $objCategories->next() ) {									// calculate distance					$iDistance = 0.0;					$iDistance = $this->_distance( $objCategories->latitude, $objCategories->longitude, $aCoordinates['latitude'], $aCoordinates['longitude'] );									// get opening times					$times = unserialize($objCategories->opening_times);					$times = !empty($times[0]['from']) ? $times : NULL;									$aEntries[] = array(						'name'			=> str_replace('&','&amp;',$objCategories->name)					,   'email'			=> $objCategories->email					,   'url'			=> $objCategories->url					,   'phone'			=> $objCategories->phone					,   'fax'			=> $objCategories->fax					,   'street'		=> $objCategories->street					,   'postal'		=> $objCategories->postal					,   'city'			=> $objCategories->city					,   'country_code'	=> $objCategories->country					,   'country_name'	=> $GLOBALS['TL_LANG']['tl_storelocator']['countries'][$objCategories->country]					,   'distance'		=> $iDistance					,	'opening_times'	=> $times					);				}								// sort entries				$aEntries = $this->msort( $aEntries, 'distance', true );								// limit results				$aEntries = array_slice( $aEntries, 0, $this->storelocator_list_limit );			}		}				$this->Template->entries = $aEntries;	}	    /**    * ModuleOpenImmoList::_distance    *    * Calculates the geographical distance between two points (in kilometers)    * @param lat1 Latitude of point 1    * @param lng1 Longitude of point 1    * @param lat2 Latitude of point 2    * @param lng2 Longitude of point 2    * @returns float    **/    protected function _distance( $lat1, $lng1, $lat2, $lng2 ) {        $pi80 = M_PI / 180;        $lat1 *= $pi80;        $lng1 *= $pi80;        $lat2 *= $pi80;        $lng2 *= $pi80;        $r = 6372.797; // mean radius of Earth in km        $dlat = $lat2 - $lat1;        $dlng = $lng2 - $lng1;        $a = sin($dlat / 2) * sin($dlat / 2) + cos($lat1) * cos($lat2) * sin($dlng / 2) * sin($dlng / 2);        $c = 2 * atan2(sqrt($a), sqrt(1 - $a));        $km = $r * $c;        return $km;    }			/**	* multidimensional array sort	* @param array Array to sort	* @param id Name of the key to order by	* @param sort_ascending Bool marker if results should be sorted ascending	* @returns array	**/	protected function msort( $array=array(), $id=NULL, $sort_ascending=true ) {		if( empty($array) || empty($id) )			return false;		$temp_array = array();		while( count($array) > 0 ) {			$lowest_id = 0;			$index=0;			foreach( $array as $item ) {				if( isset($item[$id]) ) {					if( $array[$lowest_id][$id] ) {						if ($item[$id]<$array[$lowest_id][$id])							$lowest_id = $index;					}				}				$index++;			}			$temp_array[] = $array[$lowest_id];			$array = array_merge(array_slice($array, 0,$lowest_id), array_slice($array, $lowest_id+1));		}		if( $sort_ascending )			return $temp_array;		else			return array_reverse($temp_array);	}}?>